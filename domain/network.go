package domain

// Code generated by chromebot-domain-gen. DO NOT EDIT.

import (
	"context"

	"github.com/chromedp/cdproto/cdp"
	"github.com/chromedp/cdproto/debugger"
	"github.com/chromedp/cdproto/io"
	"github.com/chromedp/cdproto/network"
)

// Network executes a cdproto command under Network domain.
type Network struct {
	ctxWithExecutor context.Context
}

// ClearBrowserCache clears browser cache.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-clearBrowserCache
func (doNetwork Network) ClearBrowserCache() (err error) {
	b := network.ClearBrowserCache()
	return b.Do(doNetwork.ctxWithExecutor)
}

// ClearBrowserCookies clears browser cookies.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-clearBrowserCookies
func (doNetwork Network) ClearBrowserCookies() (err error) {
	b := network.ClearBrowserCookies()
	return b.Do(doNetwork.ctxWithExecutor)
}

// DeleteCookies deletes browser cookies with matching name and url or
// domain/path pair.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-deleteCookies
//
// parameters:
//  - `name`: Name of the cookies to remove.
//  - `url`: This can be nil. (Optional) If specified, deletes all the cookies with the given name where domain and path match provided URL.
//  - `domain`: This can be nil. (Optional) If specified, deletes only cookies with the exact domain.
//  - `path`: This can be nil. (Optional) If specified, deletes only cookies with the exact path.
func (doNetwork Network) DeleteCookies(name string, url *string, domain *string, path *string) (err error) {
	b := network.DeleteCookies(name)
	if url != nil {
		b = b.WithURL(*url)
	}
	if domain != nil {
		b = b.WithDomain(*domain)
	}
	if path != nil {
		b = b.WithPath(*path)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// Disable disables network tracking, prevents network events from being sent
// to the client.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-disable
func (doNetwork Network) Disable() (err error) {
	b := network.Disable()
	return b.Do(doNetwork.ctxWithExecutor)
}

// EmulateNetworkConditions activates emulation of network conditions.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-emulateNetworkConditions
//
// parameters:
//  - `offline`: True to emulate internet disconnection.
//  - `latency`: Minimum latency from request sent to response headers received (ms).
//  - `downloadThroughput`: Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
//  - `uploadThroughput`: Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
//  - `connectionType`: This can be nil. (Optional) Connection type if known.
func (doNetwork Network) EmulateNetworkConditions(offline bool, latency float64, downloadThroughput float64, uploadThroughput float64, connectionType *network.ConnectionType) (err error) {
	b := network.EmulateNetworkConditions(offline, latency, downloadThroughput, uploadThroughput)
	if connectionType != nil {
		b = b.WithConnectionType(*connectionType)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// Enable enables network tracking, network events will now be delivered to
// the client.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-enable
//
// parameters:
//  - `maxTotalBufferSize`: This can be nil. (Optional) Buffer size in bytes to use when preserving network payloads (XHRs, etc).
//  - `maxResourceBufferSize`: This can be nil. (Optional) Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
//  - `maxPostDataSize`: This can be nil. (Optional) Longest post body size (in bytes) that would be included in requestWillBeSent notification
func (doNetwork Network) Enable(maxTotalBufferSize *int64, maxResourceBufferSize *int64, maxPostDataSize *int64) (err error) {
	b := network.Enable()
	if maxTotalBufferSize != nil {
		b = b.WithMaxTotalBufferSize(*maxTotalBufferSize)
	}
	if maxResourceBufferSize != nil {
		b = b.WithMaxResourceBufferSize(*maxResourceBufferSize)
	}
	if maxPostDataSize != nil {
		b = b.WithMaxPostDataSize(*maxPostDataSize)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetAllCookies returns all browser cookies. Depending on the backend
// support, will return detailed cookie information in the cookies field.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getAllCookies
//
// returns:
//  - `retCookies`: Array of cookie objects.
func (doNetwork Network) GetAllCookies() (retCookies []*network.Cookie, err error) {
	b := network.GetAllCookies()
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetCertificate returns the DER-encoded certificate.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getCertificate
//
// parameters:
//  - `origin`: Origin to get certificate for.
//
// returns:
//  - `retTableNames`
func (doNetwork Network) GetCertificate(origin string) (retTableNames []string, err error) {
	b := network.GetCertificate(origin)
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetCookies returns all browser cookies for the current URL. Depending on
// the backend support, will return detailed cookie information in the cookies
// field.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getCookies
//
// parameters:
//  - `urls`: This can be nil. (Optional) The list of URLs for which applicable cookies will be fetched
//
// returns:
//  - `retCookies`: Array of cookie objects.
func (doNetwork Network) GetCookies(urls []string) (retCookies []*network.Cookie, err error) {
	b := network.GetCookies()
	if urls != nil {
		b = b.WithUrls(urls)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetResponseBody returns content served for the given request.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getResponseBody
//
// parameters:
//  - `requestID`: Identifier of the network request to get content for.
//
// returns:
//  - `retBody`: Response body.
func (doNetwork Network) GetResponseBody(requestID network.RequestID) (retBody []byte, err error) {
	b := network.GetResponseBody(requestID)
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetRequestPostData returns post data sent with the request. Returns an
// error when no data was sent with the request.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getRequestPostData
//
// parameters:
//  - `requestID`: Identifier of the network request to get content for.
//
// returns:
//  - `retPostData`: Request body string, omitting files from multipart requests
func (doNetwork Network) GetRequestPostData(requestID network.RequestID) (retPostData string, err error) {
	b := network.GetRequestPostData(requestID)
	return b.Do(doNetwork.ctxWithExecutor)
}

// GetResponseBodyForInterception returns content served for the given
// currently intercepted request.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-getResponseBodyForInterception
//
// parameters:
//  - `interceptionID`: Identifier for the intercepted request to get body for.
//
// returns:
//  - `retBody`: Response body.
func (doNetwork Network) GetResponseBodyForInterception(interceptionID network.InterceptionID) (retBody []byte, err error) {
	b := network.GetResponseBodyForInterception(interceptionID)
	return b.Do(doNetwork.ctxWithExecutor)
}

// TakeResponseBodyForInterceptionAsStream returns a handle to the stream
// representing the response body. Note that after this command, the intercepted
// request can't be continued as is -- you either need to cancel it or to
// provide the response body. The stream only supports sequential read, IO.read
// will fail if the position is specified.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-takeResponseBodyForInterceptionAsStream
//
// parameters:
//  - `interceptionID`
//
// returns:
//  - `retStream`
func (doNetwork Network) TakeResponseBodyForInterceptionAsStream(interceptionID network.InterceptionID) (retStream io.StreamHandle, err error) {
	b := network.TakeResponseBodyForInterceptionAsStream(interceptionID)
	return b.Do(doNetwork.ctxWithExecutor)
}

// ReplayXHR this method sends a new XMLHttpRequest which is identical to the
// original one. The following parameters should be identical: method, url,
// async, request body, extra headers, withCredentials attribute, user,
// password.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-replayXHR
//
// parameters:
//  - `requestID`: Identifier of XHR to replay.
func (doNetwork Network) ReplayXHR(requestID network.RequestID) (err error) {
	b := network.ReplayXHR(requestID)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SearchInResponseBody searches for given string in response content.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-searchInResponseBody
//
// parameters:
//  - `requestID`: Identifier of the network response to search.
//  - `query`: String to search for.
//  - `caseSensitive`: This can be nil. (Optional) If true, search is case sensitive.
//  - `isRegex`: This can be nil. (Optional) If true, treats string parameter as regex.
//
// returns:
//  - `retResult`: List of search matches.
func (doNetwork Network) SearchInResponseBody(requestID network.RequestID, query string, caseSensitive *bool, isRegex *bool) (retResult []*debugger.SearchMatch, err error) {
	b := network.SearchInResponseBody(requestID, query)
	if caseSensitive != nil {
		b = b.WithCaseSensitive(*caseSensitive)
	}
	if isRegex != nil {
		b = b.WithIsRegex(*isRegex)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetBlockedURLS blocks URLs from loading.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setBlockedURLs
//
// parameters:
//  - `urls`: URL patterns to block. Wildcards ('*') are allowed.
func (doNetwork Network) SetBlockedURLS(urls []string) (err error) {
	b := network.SetBlockedURLS(urls)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetBypassServiceWorker toggles ignoring of service worker for each
// request.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setBypassServiceWorker
//
// parameters:
//  - `bypass`: Bypass service worker and load from network.
func (doNetwork Network) SetBypassServiceWorker(bypass bool) (err error) {
	b := network.SetBypassServiceWorker(bypass)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetCacheDisabled toggles ignoring cache for each request. If true, cache
// will not be used.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setCacheDisabled
//
// parameters:
//  - `cacheDisabled`: Cache disabled state.
func (doNetwork Network) SetCacheDisabled(cacheDisabled bool) (err error) {
	b := network.SetCacheDisabled(cacheDisabled)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetCookie sets a cookie with the given cookie data; may overwrite
// equivalent cookies if they exist.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setCookie
//
// parameters:
//  - `name`: Cookie name.
//  - `value`: Cookie value.
//  - `url`: This can be nil. (Optional) The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie.
//  - `domain`: This can be nil. (Optional) Cookie domain.
//  - `path`: This can be nil. (Optional) Cookie path.
//  - `secure`: This can be nil. (Optional) True if cookie is secure.
//  - `httpOnly`: This can be nil. (Optional) True if cookie is http-only.
//  - `sameSite`: This can be nil. (Optional) Cookie SameSite type.
//  - `expires`: This can be nil. (Optional) Cookie expiration date, session cookie if not set
//  - `priority`: This can be nil. (Optional) Cookie Priority type.
//
// returns:
//  - `retSuccess`: True if successfully set cookie.
func (doNetwork Network) SetCookie(name string, value string, url *string, domain *string, path *string, secure *bool, httpOnly *bool, sameSite *network.CookieSameSite, expires *cdp.TimeSinceEpoch, priority *network.CookiePriority) (retSuccess bool, err error) {
	b := network.SetCookie(name, value)
	if url != nil {
		b = b.WithURL(*url)
	}
	if domain != nil {
		b = b.WithDomain(*domain)
	}
	if path != nil {
		b = b.WithPath(*path)
	}
	if secure != nil {
		b = b.WithSecure(*secure)
	}
	if httpOnly != nil {
		b = b.WithHTTPOnly(*httpOnly)
	}
	if sameSite != nil {
		b = b.WithSameSite(*sameSite)
	}
	if expires != nil {
		b = b.WithExpires(expires)
	}
	if priority != nil {
		b = b.WithPriority(*priority)
	}
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetCookies sets given cookies.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setCookies
//
// parameters:
//  - `cookies`: Cookies to be set.
func (doNetwork Network) SetCookies(cookies []*network.CookieParam) (err error) {
	b := network.SetCookies(cookies)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetDataSizeLimitsForTest for testing.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setDataSizeLimitsForTest
//
// parameters:
//  - `maxTotalSize`: Maximum total buffer size.
//  - `maxResourceSize`: Maximum per-resource size.
func (doNetwork Network) SetDataSizeLimitsForTest(maxTotalSize int64, maxResourceSize int64) (err error) {
	b := network.SetDataSizeLimitsForTest(maxTotalSize, maxResourceSize)
	return b.Do(doNetwork.ctxWithExecutor)
}

// SetExtraHTTPHeaders specifies whether to always send extra HTTP headers
// with the requests from this page.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Network#method-setExtraHTTPHeaders
//
// parameters:
//  - `headers`: Map with extra HTTP headers.
func (doNetwork Network) SetExtraHTTPHeaders(headers network.Headers) (err error) {
	b := network.SetExtraHTTPHeaders(headers)
	return b.Do(doNetwork.ctxWithExecutor)
}
