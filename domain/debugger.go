package domain

// Code generated by chromebot-domain-gen. DO NOT EDIT.

import (
	"context"

	"github.com/chromedp/cdproto/debugger"
	"github.com/chromedp/cdproto/runtime"
)

// Debugger executes a cdproto command under Debugger domain.
type Debugger struct {
	ctxWithExecutor context.Context
}

// ContinueToLocation continues execution until specific location is reached.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-continueToLocation
//
// parameters:
//  - `location`: Location to continue to.
//  - `targetCallFrames`
func (doDebugger Debugger) ContinueToLocation(location *debugger.Location, targetCallFrames *debugger.ContinueToLocationTargetCallFrames) (err error) {
	b := debugger.ContinueToLocation(location)
	if targetCallFrames != nil {
		b = b.WithTargetCallFrames(*targetCallFrames)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// Disable disables debugger for given page.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-disable
func (doDebugger Debugger) Disable() (err error) {
	b := debugger.Disable()
	return b.Do(doDebugger.ctxWithExecutor)
}

// Enable enables debugger for the given page. Clients should not assume that
// the debugging has been enabled until the result for this command is received.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-enable
//
// parameters:
//  - `maxScriptsCacheSize`: This can be nil. (Optional) The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if parameter is omitted.
//
// returns:
//  - `retDebuggerID`: Unique identifier of the debugger.
func (doDebugger Debugger) Enable(maxScriptsCacheSize *float64) (retDebuggerID runtime.UniqueDebuggerID, err error) {
	b := debugger.Enable()
	if maxScriptsCacheSize != nil {
		b = b.WithMaxScriptsCacheSize(*maxScriptsCacheSize)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// EvaluateOnCallFrame evaluates expression on a given call frame.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-evaluateOnCallFrame
//
// parameters:
//  - `callFrameID`: Call frame identifier to evaluate on.
//  - `expression`: Expression to evaluate.
//  - `objectGroup`: This can be nil. (Optional) String object group name to put result into (allows rapid releasing resulting object handles using releaseObjectGroup).
//  - `includeCommandLineAPI`: This can be nil. (Optional) Specifies whether command line API should be available to the evaluated expression, defaults to false.
//  - `silent`: This can be nil. (Optional) In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides setPauseOnException state.
//  - `returnByValue`: This can be nil. (Optional) Whether the result is expected to be a JSON object that should be sent by value.
//  - `generatePreview`: This can be nil. (Optional) Whether preview should be generated for the result.
//  - `throwOnSideEffect`: This can be nil. (Optional) Whether to throw an exception if side effect cannot be ruled out during evaluation.
//  - `timeout`: This can be nil. (Optional) Terminate execution after timing out (number of milliseconds).
//
// returns:
//  - `retResult`: Object wrapper for the evaluation result.
//  - `retExceptionDetails`: Exception details.
func (doDebugger Debugger) EvaluateOnCallFrame(callFrameID debugger.CallFrameID, expression string, objectGroup *string, includeCommandLineAPI *bool, silent *bool, returnByValue *bool, generatePreview *bool, throwOnSideEffect *bool, timeout *runtime.TimeDelta) (retResult *runtime.RemoteObject, retExceptionDetails *runtime.ExceptionDetails, err error) {
	b := debugger.EvaluateOnCallFrame(callFrameID, expression)
	if objectGroup != nil {
		b = b.WithObjectGroup(*objectGroup)
	}
	if includeCommandLineAPI != nil {
		b = b.WithIncludeCommandLineAPI(*includeCommandLineAPI)
	}
	if silent != nil {
		b = b.WithSilent(*silent)
	}
	if returnByValue != nil {
		b = b.WithReturnByValue(*returnByValue)
	}
	if generatePreview != nil {
		b = b.WithGeneratePreview(*generatePreview)
	}
	if throwOnSideEffect != nil {
		b = b.WithThrowOnSideEffect(*throwOnSideEffect)
	}
	if timeout != nil {
		b = b.WithTimeout(*timeout)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// GetPossibleBreakpoints returns possible locations for breakpoint. scriptId
// in start and end range locations should be the same.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-getPossibleBreakpoints
//
// parameters:
//  - `start`: Start of range to search possible breakpoint locations in.
//  - `end`: This can be nil. (Optional) End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
//  - `restrictToFunction`: This can be nil. (Optional) Only consider locations which are in the same (non-nested) function as start.
//
// returns:
//  - `retLocations`: List of the possible breakpoint locations.
func (doDebugger Debugger) GetPossibleBreakpoints(start *debugger.Location, end *debugger.Location, restrictToFunction *bool) (retLocations []*debugger.BreakLocation, err error) {
	b := debugger.GetPossibleBreakpoints(start)
	if end != nil {
		b = b.WithEnd(end)
	}
	if restrictToFunction != nil {
		b = b.WithRestrictToFunction(*restrictToFunction)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// GetScriptSource returns source for the script with given id.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-getScriptSource
//
// parameters:
//  - `scriptID`: Id of the script to get source for.
//
// returns:
//  - `retScriptSource`: Script source.
func (doDebugger Debugger) GetScriptSource(scriptID runtime.ScriptID) (retScriptSource string, err error) {
	b := debugger.GetScriptSource(scriptID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// GetWasmBytecode returns bytecode for the WebAssembly script with given id.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-getWasmBytecode
//
// parameters:
//  - `scriptID`: Id of the Wasm script to get source for.
//
// returns:
//  - `retBytecode`: Script source.
func (doDebugger Debugger) GetWasmBytecode(scriptID runtime.ScriptID) (retBytecode []byte, err error) {
	b := debugger.GetWasmBytecode(scriptID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// GetStackTrace returns stack trace with given stackTraceId.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-getStackTrace
//
// parameters:
//  - `stackTraceID`
//
// returns:
//  - `retStackTrace`
func (doDebugger Debugger) GetStackTrace(stackTraceID *runtime.StackTraceID) (retStackTrace *runtime.StackTrace, err error) {
	b := debugger.GetStackTrace(stackTraceID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// Pause stops on the next JavaScript statement.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-pause
func (doDebugger Debugger) Pause() (err error) {
	b := debugger.Pause()
	return b.Do(doDebugger.ctxWithExecutor)
}

// RemoveBreakpoint removes JavaScript breakpoint.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-removeBreakpoint
//
// parameters:
//  - `breakpointID`
func (doDebugger Debugger) RemoveBreakpoint(breakpointID debugger.BreakpointID) (err error) {
	b := debugger.RemoveBreakpoint(breakpointID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// RestartFrame restarts particular call frame from the beginning.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-restartFrame
//
// parameters:
//  - `callFrameID`: Call frame identifier to evaluate on.
//
// returns:
//  - `retCallFrames`: New stack trace.
//  - `retAsyncStackTrace`: Async stack trace, if any.
//  - `retAsyncStackTraceID`: Async stack trace, if any.
func (doDebugger Debugger) RestartFrame(callFrameID debugger.CallFrameID) (retCallFrames []*debugger.CallFrame, retAsyncStackTrace *runtime.StackTrace, retAsyncStackTraceID *runtime.StackTraceID, err error) {
	b := debugger.RestartFrame(callFrameID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// Resume resumes JavaScript execution.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-resume
func (doDebugger Debugger) Resume() (err error) {
	b := debugger.Resume()
	return b.Do(doDebugger.ctxWithExecutor)
}

// SearchInContent searches for given string in script content.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-searchInContent
//
// parameters:
//  - `scriptID`: Id of the script to search in.
//  - `query`: String to search for.
//  - `caseSensitive`: This can be nil. (Optional) If true, search is case sensitive.
//  - `isRegex`: This can be nil. (Optional) If true, treats string parameter as regex.
//
// returns:
//  - `retResult`: List of search matches.
func (doDebugger Debugger) SearchInContent(scriptID runtime.ScriptID, query string, caseSensitive *bool, isRegex *bool) (retResult []*debugger.SearchMatch, err error) {
	b := debugger.SearchInContent(scriptID, query)
	if caseSensitive != nil {
		b = b.WithCaseSensitive(*caseSensitive)
	}
	if isRegex != nil {
		b = b.WithIsRegex(*isRegex)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetAsyncCallStackDepth enables or disables async call stacks tracking.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setAsyncCallStackDepth
//
// parameters:
//  - `maxDepth`: Maximum depth of async call stacks. Setting to 0 will effectively disable collecting async call stacks (default).
func (doDebugger Debugger) SetAsyncCallStackDepth(maxDepth int64) (err error) {
	b := debugger.SetAsyncCallStackDepth(maxDepth)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBlackboxPatterns replace previous blackbox patterns with passed ones.
// Forces backend to skip stepping/pausing in scripts with url matching one of
// the patterns. VM will try to leave blackboxed script by performing 'step in'
// several times, finally resorting to 'step out' if unsuccessful.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBlackboxPatterns
//
// parameters:
//  - `patterns`: Array of regexps that will be used to check script url for blackbox state.
func (doDebugger Debugger) SetBlackboxPatterns(patterns []string) (err error) {
	b := debugger.SetBlackboxPatterns(patterns)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBlackboxedRanges makes backend skip steps in the script in blackboxed
// ranges. VM will try leave blacklisted scripts by performing 'step in' several
// times, finally resorting to 'step out' if unsuccessful. Positions array
// contains positions where blackbox state is changed. First interval isn't
// blackboxed. Array should be sorted.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBlackboxedRanges
//
// parameters:
//  - `scriptID`: Id of the script.
//  - `positions`
func (doDebugger Debugger) SetBlackboxedRanges(scriptID runtime.ScriptID, positions []*debugger.ScriptPosition) (err error) {
	b := debugger.SetBlackboxedRanges(scriptID, positions)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBreakpoint sets JavaScript breakpoint at a given location.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBreakpoint
//
// parameters:
//  - `location`: Location to set breakpoint in.
//  - `condition`: This can be nil. (Optional) Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
//
// returns:
//  - `retBreakpointID`: Id of the created breakpoint for further reference.
//  - `retActualLocation`: Location this breakpoint resolved into.
func (doDebugger Debugger) SetBreakpoint(location *debugger.Location, condition *string) (retBreakpointID debugger.BreakpointID, retActualLocation *debugger.Location, err error) {
	b := debugger.SetBreakpoint(location)
	if condition != nil {
		b = b.WithCondition(*condition)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetInstrumentationBreakpoint sets instrumentation breakpoint.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setInstrumentationBreakpoint
//
// parameters:
//  - `instrumentation`: Instrumentation name.
//
// returns:
//  - `retBreakpointID`: Id of the created breakpoint for further reference.
func (doDebugger Debugger) SetInstrumentationBreakpoint(instrumentation debugger.SetInstrumentationBreakpointInstrumentation) (retBreakpointID debugger.BreakpointID, err error) {
	b := debugger.SetInstrumentationBreakpoint(instrumentation)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBreakpointByURL sets JavaScript breakpoint at given location specified
// either by URL or URL regex. Once this command is issued, all existing parsed
// scripts will have breakpoints resolved and returned in locations property.
// Further matching script parsing will result in subsequent breakpointResolved
// events issued. This logical breakpoint will survive page reloads.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBreakpointByUrl
//
// parameters:
//  - `lineNumber`: Line number to set breakpoint at.
//  - `url`: This can be nil. (Optional) URL of the resources to set breakpoint on.
//  - `urlRegex`: This can be nil. (Optional) Regex pattern for the URLs of the resources to set breakpoints on. Either url or urlRegex must be specified.
//  - `scriptHash`: This can be nil. (Optional) Script hash of the resources to set breakpoint on.
//  - `columnNumber`: This can be nil. (Optional) Offset in the line to set breakpoint at.
//  - `condition`: This can be nil. (Optional) Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
//
// returns:
//  - `retBreakpointID`: Id of the created breakpoint for further reference.
//  - `retLocations`: List of the locations this breakpoint resolved into upon addition.
func (doDebugger Debugger) SetBreakpointByURL(lineNumber int64, url *string, urlRegex *string, scriptHash *string, columnNumber *int64, condition *string) (retBreakpointID debugger.BreakpointID, retLocations []*debugger.Location, err error) {
	b := debugger.SetBreakpointByURL(lineNumber)
	if url != nil {
		b = b.WithURL(*url)
	}
	if urlRegex != nil {
		b = b.WithURLRegex(*urlRegex)
	}
	if scriptHash != nil {
		b = b.WithScriptHash(*scriptHash)
	}
	if columnNumber != nil {
		b = b.WithColumnNumber(*columnNumber)
	}
	if condition != nil {
		b = b.WithCondition(*condition)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBreakpointOnFunctionCall sets JavaScript breakpoint before each call to
// the given function. If another function was created from the same source as a
// given one, calling it will also trigger the breakpoint.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBreakpointOnFunctionCall
//
// parameters:
//  - `objectID`: Function object id.
//  - `condition`: This can be nil. (Optional) Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
//
// returns:
//  - `retBreakpointID`: Id of the created breakpoint for further reference.
func (doDebugger Debugger) SetBreakpointOnFunctionCall(objectID runtime.RemoteObjectID, condition *string) (retBreakpointID debugger.BreakpointID, err error) {
	b := debugger.SetBreakpointOnFunctionCall(objectID)
	if condition != nil {
		b = b.WithCondition(*condition)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetBreakpointsActive activates / deactivates all breakpoints on the page.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setBreakpointsActive
//
// parameters:
//  - `active`: New value for breakpoints active state.
func (doDebugger Debugger) SetBreakpointsActive(active bool) (err error) {
	b := debugger.SetBreakpointsActive(active)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetPauseOnExceptions defines pause on exceptions state. Can be set to stop
// on all exceptions, uncaught exceptions or no exceptions. Initial pause on
// exceptions state is none.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setPauseOnExceptions
//
// parameters:
//  - `state`: Pause on exceptions mode.
func (doDebugger Debugger) SetPauseOnExceptions(state debugger.ExceptionsState) (err error) {
	b := debugger.SetPauseOnExceptions(state)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetReturnValue changes return value in top frame. Available only at return
// break position.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setReturnValue
//
// parameters:
//  - `newValue`: New return value.
func (doDebugger Debugger) SetReturnValue(newValue *runtime.CallArgument) (err error) {
	b := debugger.SetReturnValue(newValue)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetScriptSource edits JavaScript source live.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setScriptSource
//
// parameters:
//  - `scriptID`: Id of the script to edit.
//  - `scriptSource`: New content of the script.
//  - `dryRun`: This can be nil. (Optional) If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
//
// returns:
//  - `retCallFrames`: New stack trace in case editing has happened while VM was stopped.
//  - `retStackChanged`: Whether current call stack  was modified after applying the changes.
//  - `retAsyncStackTrace`: Async stack trace, if any.
//  - `retAsyncStackTraceID`: Async stack trace, if any.
//  - `retExceptionDetails`: Exception details if any.
func (doDebugger Debugger) SetScriptSource(scriptID runtime.ScriptID, scriptSource string, dryRun *bool) (retCallFrames []*debugger.CallFrame, retStackChanged bool, retAsyncStackTrace *runtime.StackTrace, retAsyncStackTraceID *runtime.StackTraceID, retExceptionDetails *runtime.ExceptionDetails, err error) {
	b := debugger.SetScriptSource(scriptID, scriptSource)
	if dryRun != nil {
		b = b.WithDryRun(*dryRun)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetSkipAllPauses makes page not interrupt on any pauses (breakpoint,
// exception, dom exception etc).
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setSkipAllPauses
//
// parameters:
//  - `skip`: New value for skip pauses state.
func (doDebugger Debugger) SetSkipAllPauses(skip bool) (err error) {
	b := debugger.SetSkipAllPauses(skip)
	return b.Do(doDebugger.ctxWithExecutor)
}

// SetVariableValue changes value of variable in a callframe. Object-based
// scopes are not supported and must be mutated manually.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-setVariableValue
//
// parameters:
//  - `scopeNumber`: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
//  - `variableName`: Variable name.
//  - `newValue`: New variable value.
//  - `callFrameID`: Id of callframe that holds variable.
func (doDebugger Debugger) SetVariableValue(scopeNumber int64, variableName string, newValue *runtime.CallArgument, callFrameID debugger.CallFrameID) (err error) {
	b := debugger.SetVariableValue(scopeNumber, variableName, newValue, callFrameID)
	return b.Do(doDebugger.ctxWithExecutor)
}

// StepInto steps into the function call.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-stepInto
//
// parameters:
//  - `breakOnAsyncCall`: This can be nil. (Optional) Debugger will pause on the execution of the first async task which was scheduled before next pause.
func (doDebugger Debugger) StepInto(breakOnAsyncCall *bool) (err error) {
	b := debugger.StepInto()
	if breakOnAsyncCall != nil {
		b = b.WithBreakOnAsyncCall(*breakOnAsyncCall)
	}
	return b.Do(doDebugger.ctxWithExecutor)
}

// StepOut steps out of the function call.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-stepOut
func (doDebugger Debugger) StepOut() (err error) {
	b := debugger.StepOut()
	return b.Do(doDebugger.ctxWithExecutor)
}

// StepOver steps over the statement.
//
// See: https://chromedevtools.github.io/devtools-protocol/tot/Debugger#method-stepOver
func (doDebugger Debugger) StepOver() (err error) {
	b := debugger.StepOver()
	return b.Do(doDebugger.ctxWithExecutor)
}
